<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>WebAR: 粒子战马·重塑进化版</title><style>body{margin:0;overflow:hidden;background-color:#000;font-family:'Microsoft YaHei',sans-serif}#container{position:relative;width:100vw;height:100vh;background:radial-gradient(circle at center,#1a0500 0,#000 100%)}#input_video{position:absolute;bottom:10px;right:10px;width:160px;height:120px;transform:scaleX(-1);border:1px solid #ffd700;z-index:100;opacity:.5;border-radius:8px;object-fit:cover}#output_canvas{position:absolute;top:0;left:0;width:100%;height:100%;z-index:10}#ui-layer{position:absolute;top:0;left:0;width:100%;height:100%;z-index:20;pointer-events:none;display:flex;flex-direction:column;justify-content:flex-end;align-items:center;padding-bottom:50px}#status-box{background:rgba(0,0,0,0.6);padding:15px 40px;border-radius:40px;border:1px solid #ffd700;box-shadow:0 0 20px rgba(255,215,0,0.3);text-align:center;backdrop-filter:blur(5px);transition:all .3s}h2{margin:0;color:#ffd700;font-size:24px;text-shadow:0 0 10px #ffd700;letter-spacing:2px}p{margin:5px 0 0;color:#fff;font-size:14px;opacity:.9}#loading-layer{position:absolute;top:0;left:0;width:100%;height:100%;background:#000;z-index:50;display:flex;flex-direction:column;justify-content:center;align-items:center;color:#ffd700}</style></head><body><div id="loading-layer"><h3 id="loading-text">正在加载高精度战马模型...</h3></div><div id="ui-layer"><div id="status-box"><h2 id="main-status">系统启动中</h2><p id="sub-status">握拳召唤战马 · 张手号令冲锋 · 手高低控视角 · 旋转手掌转方向</p></div></div><div id="container"><video id="input_video" autoplay playsinline muted></video><canvas id="output_canvas"></canvas></div><script src="libs/mediapipe/hands.js"></script><script type="importmap">{"imports":{"three":"./libs/three/three.module.js","three/examples/jsm/":"./libs/three/examples/jsm/"}}</script><script type="module">import*as THREE from'three';import{GLTFLoader}from'three/examples/jsm/loaders/GLTFLoader.js';import{MeshSurfaceSampler}from'three/examples/jsm/math/MeshSurfaceSampler.js';const RAIN_COUNT=8000;const HORSE_COUNT=200000;const RUN_SPEED_SCALE=8;const DEFAULT_ROTATION=-Math.PI*0.15;const MODEL_SCALE=0.04;let scene,camera,renderer,clock;let systemMa,systemFu,systemHorse,systemDust,systemStars;const DUST_COUNT=5000;const STAR_COUNT=200;let dustPositions=[];let starData=[];let rainPositionsMa=[],rainPositionsFu=[];let targetPositions=[];let currentState='RAIN';let isHandDetected=false;let handCenterX=0.5,horseGroupX=0,horseRotationY=DEFAULT_ROTATION;let handCenterY=0.5;let handAngle=0;let smoothHandX=0.5,smoothHandY=0.5,smoothHandAngle=0;const HAND_SMOOTH=0.1;let pendingState='RAIN';let stateTimer=0;const STATE_DEBOUNCE=0.8;let globalTime=0;let modelLoaded=false;let forwardIsZ=false;const TOTAL_HORSES=240;let horseFormation=null;let modelMinY=0,modelMaxY=1,modelMinX=0,modelMaxX=1;const videoElement=document.getElementById('input_video');const uiMain=document.getElementById('main-status');const loadingLayer=document.getElementById('loading-layer');const loadingText=document.getElementById('loading-text');function generateHorseFromModel(mesh,gltf){targetPositions=[];const geo=mesh.geometry;const hasMorphs=geo.morphAttributes&&geo.morphAttributes.position&&geo.morphAttributes.position.length>0;console.log('Morph targets available:',hasMorphs,hasMorphs?geo.morphAttributes.position.length:0);if(hasMorphs){const morphCount=geo.morphAttributes.position.length;mesh.updateMorphTargets();if(!mesh.morphTargetInfluences||mesh.morphTargetInfluences.length===0){mesh.morphTargetInfluences=new Array(morphCount).fill(0);}
let bestFrame=-1;let bestScore=Infinity;const testCount=2000;for(let frame=0;frame<morphCount;frame++){for(let m=0;m<morphCount;m++){mesh.morphTargetInfluences[m]=(m===frame)?1:0;}
const sampler=new MeshSurfaceSampler(mesh).build();const tp=new THREE.Vector3();const quadY={FL:[],FR:[],BL:[],BR:[]};let minYt=Infinity,maxYt=-Infinity;let minXt=Infinity,maxXt=-Infinity;let minZt=Infinity,maxZt=-Infinity;const pts=[];for(let i=0;i<testCount;i++){sampler.sample(tp);pts.push({x:tp.x,y:tp.y,z:tp.z});minYt=Math.min(minYt,tp.y);maxYt=Math.max(maxYt,tp.y);minXt=Math.min(minXt,tp.x);maxXt=Math.max(maxXt,tp.x);minZt=Math.min(minZt,tp.z);maxZt=Math.max(maxZt,tp.z);}
const ht=maxYt-minYt;const wt=maxZt-minZt;const lt=maxXt-minXt;const fwdZ=wt>lt;pts.forEach(p=>{const ny=(p.y-minYt)/ht;if(ny>=0.45)return;const nF=fwdZ?(p.z-minZt)/wt:(p.x-minXt)/lt;const nS=fwdZ?(p.x-minXt)/lt:(p.z-minZt)/wt;const key=(nF>0.5?'F':'B')+(nS>0.5?'L':'R');quadY[key].push(p.y);});const avgs={};let allAvg=0,cnt=0;for(const[k,arr]of Object.entries(quadY)){if(arr.length===0){avgs[k]=0;continue;}
avgs[k]=arr.reduce((a,b)=>a+b,0)/arr.length;allAvg+=avgs[k];cnt++;}
allAvg/=(cnt||1);let variance=0;for(const v of Object.values(avgs)){variance+=(v-allAvg)*(v-allAvg);}
if(variance<bestScore){bestScore=variance;bestFrame=frame;}}
console.log('Best standing frame:',bestFrame,'variance:',bestScore.toFixed(6));if(bestFrame>=0){for(let m=0;m<morphCount;m++){mesh.morphTargetInfluences[m]=(m===bestFrame)?1:0;}}}
const sampler=new MeshSurfaceSampler(mesh).build();const tempPos=new THREE.Vector3();const samplePoints=[];for(let i=0;i<HORSE_COUNT;i++){sampler.sample(tempPos);samplePoints.push({x:tempPos.x*MODEL_SCALE,y:tempPos.y*MODEL_SCALE,z:tempPos.z*MODEL_SCALE});}
modelMinY=Infinity;modelMaxY=-Infinity;modelMinX=Infinity;modelMaxX=-Infinity;let minZ=Infinity,maxZ=-Infinity;samplePoints.forEach(p=>{modelMinY=Math.min(modelMinY,p.y);modelMaxY=Math.max(modelMaxY,p.y);modelMinX=Math.min(modelMinX,p.x);modelMaxX=Math.max(modelMaxX,p.x);minZ=Math.min(minZ,p.z);maxZ=Math.max(maxZ,p.z);});const height=modelMaxY-modelMinY;const length=modelMaxX-modelMinX;const width=maxZ-minZ;console.log('Model bounds:',{x:[modelMinX.toFixed(2),modelMaxX.toFixed(2),'len:'+length.toFixed(2)],y:[modelMinY.toFixed(2),modelMaxY.toFixed(2),'h:'+height.toFixed(2)],z:[minZ.toFixed(2),maxZ.toFixed(2),'w:'+width.toFixed(2)]});forwardIsZ=width>length;console.log('Forward axis:',forwardIsZ?'Z':'X');const midSide=forwardIsZ?(modelMinX+modelMaxX)/2:(minZ+maxZ)/2;samplePoints.forEach(p=>{const ny=(p.y-modelMinY)/height;const nForward=forwardIsZ?(p.z-minZ)/width:(p.x-modelMinX)/length;const nSide=forwardIsZ?(p.x-modelMinX)/length:(p.z-minZ)/width;let bone='body';let t=Math.random();if(ny<0.45){const isFront=nForward>0.5;const isLeft=nSide>0.5;if(isFront&&isLeft)bone='legFL';else if(isFront&&!isLeft)bone='legFR';else if(!isFront&&isLeft)bone='legBL';else bone='legBR';t=1.0-ny/0.45;}
else if(nForward>0.85&&ny>0.5){bone='head';}
else if(nForward>0.7&&ny>0.45){bone='neck';t=(nForward-0.7)/0.3;}
else if(nForward<0.1){bone='tail';t=1.0-nForward/0.1;}
else if(ny>0.82&&nForward>0.45){bone='mane';t=(nForward-0.45)/0.55;}
targetPositions.push({x:p.x,y:p.y,z:p.z,bone,t,nForward,nSide});});const boneCounts={};targetPositions.forEach(p=>{boneCounts[p.bone]=(boneCounts[p.bone]||0)+1;});console.log('Bone counts:',boneCounts);const legGroups={legFL:[],legFR:[],legBL:[],legBR:[]};targetPositions.forEach((p,i)=>{if(p.bone in legGroups)legGroups[p.bone].push(i);});const legStats={};for(const[name,indices]of Object.entries(legGroups)){if(indices.length===0){legStats[name]={avg:0,min:0,avgFwd:0,avgSide:0};continue;}
let sumY=0,minLegY=Infinity,sumFwd=0,sumSide=0;indices.forEach(i=>{const p=targetPositions[i];sumY+=p.y;minLegY=Math.min(minLegY,p.y);sumFwd+=forwardIsZ?p.z:p.x;sumSide+=forwardIsZ?p.x:p.z;});legStats[name]={avg:sumY/indices.length,min:minLegY,avgFwd:sumFwd/indices.length,avgSide:sumSide/indices.length};}
console.log('Leg stats:',legStats);const pairs=[['legFL','legFR'],['legBL','legBR']];for(const[legA,legB]of pairs){const sA=legStats[legA],sB=legStats[legB];const goodLeg=sA.avg<=sB.avg?legA:legB;const badLeg=sA.avg<=sB.avg?legB:legA;console.log(`Cloning ${goodLeg} (avgY=${legStats[goodLeg].avg.toFixed(4)}) -> ${badLeg} (avgY=${legStats[badLeg].avg.toFixed(4)})`);const goodIdx=legGroups[goodLeg];const badIdx=legGroups[badLeg];for(let i=0;i<badIdx.length;i++){const src=targetPositions[goodIdx[i%goodIdx.length]];const dst=targetPositions[badIdx[i]];dst.y=src.y;dst.t=src.t;dst.nForward=src.nForward;dst.nSide=1.0-src.nSide;if(forwardIsZ){dst.z=src.z;dst.x=2*midSide-src.x;}else{dst.x=src.x;dst.z=2*midSide-src.z;}}
console.log(`Done: ${goodLeg} -> ${badLeg}, midSide=${midSide.toFixed(4)}`);}
const legClones=[];const cloneOffset=0.003;for(let i=0;i<targetPositions.length;i++){const p=targetPositions[i];if(p.bone.startsWith('leg')){for(let c=0;c<2;c++){const seed=Math.sin((i*7+c*13)*43758.5453);const ox=((seed%1+1)%1-0.5)*cloneOffset;const oy=((Math.sin(seed*127.1)%1+1)%1-0.5)*cloneOffset;const oz=((Math.sin(seed*269.5)%1+1)%1-0.5)*cloneOffset;legClones.push({x:p.x+ox,y:p.y+oy,z:p.z+oz,bone:p.bone,t:p.t,nForward:p.nForward,nSide:p.nSide});}}}
targetPositions.push(...legClones);console.log('Leg clones added:',legClones.length,'Total targets:',targetPositions.length);modelLoaded=true;loadingLayer.style.display='none';}
function getGallop(time,nForward,nSide){const isFront=nForward>0.5;const isLeft=nSide>0.5;const phase=((isFront&&isLeft)||(!isFront&&!isLeft))?0:Math.PI;const cycle=time*RUN_SPEED_SCALE+phase;const swing=Math.sin(cycle);const lift=Math.max(0,Math.sin(cycle));return{stride:isFront?swing*1.5:swing*-1.2,liftY:lift*0.8,kneeBendForward:-lift*0.4,kneeBendY:lift*0.3};}
function getManyHorseGallop(time,nForward,nSide,horseId){const isFront=nForward>0.5;const isLeft=nSide>0.5;const phase=((isFront&&isLeft)||(!isFront&&!isLeft))?0:Math.PI;const speedMul=1.0+((Math.sin(horseId*173.7)*43758.5453%1+1)%1)*0.5;const phaseOff=horseId*2.7;const cycle=(time+phaseOff)*RUN_SPEED_SCALE*1.3*speedMul+phase;const swing=Math.sin(cycle);const lift=Math.max(0,Math.sin(cycle));return{stride:isFront?swing*2.8:swing*-2.2,liftY:lift*1.6,kneeBendForward:-lift*0.7,kneeBendY:lift*0.5};}
function getManyHorseBodyMotion(time,horseId){const speedMul=1.0+((Math.sin(horseId*173.7)*43758.5453%1+1)%1)*0.5;const phaseOff=horseId*2.7;const cycle=(time+phaseOff)*RUN_SPEED_SCALE*1.3*speedMul;return{bounce:Math.sin(cycle*2)*0.25,pitch:Math.sin(cycle*2)*0.06,roll:Math.sin(cycle)*0.02};}
function getBodyMotion(time){const cycle=time*RUN_SPEED_SCALE;return{bounce:Math.sin(cycle*2)*0.12,pitch:Math.sin(cycle*2)*0.03,roll:Math.sin(cycle)*0.015};}
function createTextTexture(text,color){const c=document.createElement('canvas');c.width=128;c.height=128;const ctx=c.getContext('2d');ctx.font='bold 100px "Microsoft YaHei"';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillStyle=color;ctx.fillText(text,64,64);return new THREE.CanvasTexture(c);}
function createGlowTexture(){const c=document.createElement('canvas');c.width=64;c.height=64;const ctx=c.getContext('2d');const grad=ctx.createRadialGradient(32,32,0,32,32,32);grad.addColorStop(0,'rgba(255,255,255,1)');grad.addColorStop(0.15,'rgba(255,230,150,0.9)');grad.addColorStop(0.4,'rgba(255,160,30,0.4)');grad.addColorStop(0.7,'rgba(255,80,0,0.1)');grad.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=grad;ctx.fillRect(0,0,64,64);return new THREE.CanvasTexture(c);}
function initParticleSystems(){const geoMa=new THREE.BufferGeometry(),geoFu=new THREE.BufferGeometry();const posMa=new Float32Array(RAIN_COUNT*3),posFu=new Float32Array(RAIN_COUNT*3);for(let i=0;i<RAIN_COUNT;i++){rainPositionsMa.push({x:(Math.random()-0.5)*40,y:Math.random()*30,z:(Math.random()-0.5)*25,speed:0.05+Math.random()*0.12});rainPositionsFu.push({x:(Math.random()-0.5)*40,y:Math.random()*30,z:(Math.random()-0.5)*25,speed:0.05+Math.random()*0.12});}
geoMa.setAttribute('position',new THREE.BufferAttribute(posMa,3));geoFu.setAttribute('position',new THREE.BufferAttribute(posFu,3));systemMa=new THREE.Points(geoMa,new THREE.PointsMaterial({map:createTextTexture("马","#FFD700"),size:0.55,transparent:true,opacity:0.8,blending:THREE.AdditiveBlending,depthWrite:false}));systemFu=new THREE.Points(geoFu,new THREE.PointsMaterial({map:createTextTexture("福","#FF2222"),size:0.6,transparent:true,opacity:0.8,blending:THREE.AdditiveBlending,depthWrite:false}));scene.add(systemMa,systemFu);const geoHorse=new THREE.BufferGeometry();const posHorse=new Float32Array(HORSE_COUNT*3);const colHorse=new Float32Array(HORSE_COUNT*3);const sizeHorse=new Float32Array(HORSE_COUNT);for(let i=0;i<HORSE_COUNT;i++){posHorse[i*3]=(Math.random()-0.5)*15;posHorse[i*3+1]=(Math.random()-0.5)*15;posHorse[i*3+2]=(Math.random()-0.5)*15;const bone=targetPositions[i%targetPositions.length].bone;let r=1,g=0.84,b=0;if(bone==='mane'||bone==='tail'){r=1;g=0.5+Math.random()*0.3;b=Math.random()*0.15;}else if(bone.startsWith('leg')){r=1;g=0.7+Math.random()*0.2;b=0.1;}
colHorse[i*3]=r;colHorse[i*3+1]=g;colHorse[i*3+2]=b;sizeHorse[i]=(bone==='mane'||bone==='tail')?1.3:bone.startsWith('leg')?1.4:1.0;}
geoHorse.setAttribute('position',new THREE.BufferAttribute(posHorse,3));geoHorse.setAttribute('color',new THREE.BufferAttribute(colHorse,3));geoHorse.setAttribute('aSize',new THREE.BufferAttribute(sizeHorse,1));const horseMat=new THREE.ShaderMaterial({uniforms:{uTexture:{value:createGlowTexture()},uOpacity:{value:0},uBaseSize:{value:0.12*window.devicePixelRatio}},vertexShader:`
                    attribute float aSize;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float uBaseSize;
                    void main() {
                        vColor = color;
                        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = uBaseSize * aSize * (300.0 / -mvPos.z);
                        gl_Position = projectionMatrix * mvPos;
                    }
                `,fragmentShader:`
                    uniform sampler2D uTexture;
                    uniform float uOpacity;
                    varying vec3 vColor;
                    void main() {
                        vec4 tex = texture2D(uTexture, gl_PointCoord);
                        gl_FragColor = vec4(vColor * tex.rgb, tex.a * uOpacity);
                    }
                `,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false});systemHorse=new THREE.Points(geoHorse,horseMat);scene.add(systemHorse);const geoDust=new THREE.BufferGeometry();const posDust=new Float32Array(DUST_COUNT*3);const sizeDust=new Float32Array(DUST_COUNT);for(let i=0;i<DUST_COUNT;i++){posDust[i*3]=(Math.random()-0.5)*30;posDust[i*3+1]=Math.random()*2-1;posDust[i*3+2]=(Math.random()-0.5)*30;dustPositions.push({x:(Math.random()-0.5)*30,y:Math.random()*2-1,z:(Math.random()-0.5)*30,vx:(Math.random()-0.5)*0.3,vy:Math.random()*0.15,vz:(Math.random()-0.5)*0.3,life:Math.random()});sizeDust[i]=0.5+Math.random()*1.5;}
geoDust.setAttribute('position',new THREE.BufferAttribute(posDust,3));geoDust.setAttribute('aSize',new THREE.BufferAttribute(sizeDust,1));const dustMat=new THREE.PointsMaterial({color:0xFFAA44,size:0.5,transparent:true,opacity:0,blending:THREE.AdditiveBlending,depthWrite:false,map:createGlowTexture(),sizeAttenuation:true});systemDust=new THREE.Points(geoDust,dustMat);scene.add(systemDust);const geoStars=new THREE.BufferGeometry();const posStars=new Float32Array(STAR_COUNT*3);const sizeStars=new Float32Array(STAR_COUNT);const colStars=new Float32Array(STAR_COUNT*3);for(let i=0;i<STAR_COUNT;i++){const angle=Math.random()*Math.PI*2;const r=3+Math.random()*9;const y=-7+Math.random()*12;posStars[i*3]=Math.cos(angle)*r;posStars[i*3+1]=y;posStars[i*3+2]=Math.sin(angle)*r;sizeStars[i]=0.5+Math.random()*1.5;const warmth=Math.random();colStars[i*3]=1.0;colStars[i*3+1]=0.85+warmth*0.15;colStars[i*3+2]=0.6+warmth*0.3;starData.push({twinkleSpeed:0.3+Math.random()*1.5,twinklePhase:Math.random()*Math.PI*2,baseSize:sizeStars[i]});}
geoStars.setAttribute('position',new THREE.BufferAttribute(posStars,3));geoStars.setAttribute('aSize',new THREE.BufferAttribute(sizeStars,1));geoStars.setAttribute('color',new THREE.BufferAttribute(colStars,3));const starTex=(function(){const c=document.createElement('canvas');c.width=128;c.height=128;const ctx=c.getContext('2d');const cx=64,cy=64;const grad=ctx.createRadialGradient(cx,cy,0,cx,cy,64);grad.addColorStop(0,'rgba(255,255,255,1)');grad.addColorStop(0.05,'rgba(255,250,230,0.9)');grad.addColorStop(0.15,'rgba(255,240,200,0.4)');grad.addColorStop(0.4,'rgba(255,220,150,0.1)');grad.addColorStop(1,'rgba(0,0,0,0)');ctx.fillStyle=grad;ctx.fillRect(0,0,128,128);ctx.globalCompositeOperation='lighter';for(let a=0;a<4;a++){ctx.save();ctx.translate(cx,cy);ctx.rotate(a*Math.PI/4);const lg=ctx.createLinearGradient(0,0,60,0);lg.addColorStop(0,'rgba(255,255,255,0.8)');lg.addColorStop(0.3,'rgba(255,240,200,0.3)');lg.addColorStop(1,'rgba(255,220,150,0)');ctx.fillStyle=lg;ctx.fillRect(0,-1.5,60,3);ctx.fillRect(-60,-1.5,60,3);ctx.restore();}
return new THREE.CanvasTexture(c);})();const starMat=new THREE.ShaderMaterial({uniforms:{uTexture:{value:starTex},uOpacity:{value:0},uBaseSize:{value:0.6*window.devicePixelRatio}},vertexShader:`
                    attribute float aSize;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float uBaseSize;
                    void main() {
                        vColor = color;
                        vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = uBaseSize * aSize * (300.0 / -mvPos.z);
                        gl_Position = projectionMatrix * mvPos;
                    }
                `,fragmentShader:`
                    uniform sampler2D uTexture;
                    uniform float uOpacity;
                    varying vec3 vColor;
                    void main() {
                        vec4 tex = texture2D(uTexture, gl_PointCoord);
                        gl_FragColor = vec4(vColor * tex.rgb * 2.0, tex.a * uOpacity);
                    }
                `,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false});systemStars=new THREE.Points(geoStars,starMat);scene.add(systemStars);horseFormation=new Array(TOTAL_HORSES);const COL_WIDTH=3.5;const ROW_DEPTH=5.0;for(let hid=0;hid<TOTAL_HORSES;hid++){if(hid===0){horseFormation[hid]={offX:0,offZ:0,sc:1.0,speedMul:1.0,phaseOff:0,rushSpeed:1.0,rushPhase:0};continue;}
const row=Math.floor(Math.sqrt(2*hid));const colsInRow=row+1;const idInRow=hid-Math.floor(row*(row+1)/2);const col=idInRow-(colsInRow-1)/2;const jx=Math.sin(hid*127.1)*43758.5453;const jz=Math.sin(hid*269.5)*43758.5453;const jitterX=((jx-Math.floor(jx))-0.5)*2.0;const jitterZ=((jz-Math.floor(jz))-0.5)*2.0;const offX=-(row*ROW_DEPTH)+jitterX;const offZ=col*COL_WIDTH+jitterZ;const depthRatio=Math.min(row/20,1.0);const rndSc=((Math.sin(hid*419.2)*43758.5453)%1+1)%1;const sc=Math.max(1.0-depthRatio*0.5+rndSc*0.08,0.4);const speedMul=1.0+((Math.sin(hid*173.7)*43758.5453%1+1)%1)*0.5;const phaseOff=hid*2.7;const rushSpeed=0.8+(((Math.sin(hid*337.3)*43758.5453)%1+1)%1)*0.6;const rushPhase=hid*3.7;horseFormation[hid]={offX,offZ,sc,speedMul,phaseOff,rushSpeed,rushPhase,row};}}
function updateLogic(){const dt=clock.getDelta();globalTime+=dt;if(!modelLoaded)return;smoothHandX+=(handCenterX-smoothHandX)*HAND_SMOOTH;smoothHandY+=(handCenterY-smoothHandY)*HAND_SMOOTH;smoothHandAngle+=(handAngle-smoothHandAngle)*HAND_SMOOTH;if(pendingState!==currentState){stateTimer+=dt;if(stateTimer>=STATE_DEBOUNCE){currentState=pendingState;if(currentState==='ONE_HORSE'){uiMain.innerText=" 聚力：粒子战马";uiMain.style.color="#FFD700";horseGroupX=0;horseRotationY=DEFAULT_ROTATION;}else if(currentState==='MANY_HORSES'){uiMain.innerText=" 冲锋：万马奔腾";uiMain.style.color="#FF4500";}else{uiMain.innerText="福满乾坤";uiMain.style.color="#fff";for(let i=0;i<RAIN_COUNT;i++){rainPositionsMa[i].x=(Math.random()-0.5)*40;rainPositionsMa[i].y=Math.random()*30;rainPositionsMa[i].z=(Math.random()-0.5)*25;rainPositionsMa[i].absorbed=false;rainPositionsFu[i].x=(Math.random()-0.5)*40;rainPositionsFu[i].y=Math.random()*30;rainPositionsFu[i].z=(Math.random()-0.5)*25;rainPositionsFu[i].absorbed=false;}}}}
const alphaStep=0.08;const horseOpacity=systemHorse.material.uniforms.uOpacity;if(currentState==='RAIN'){systemMa.material.opacity=THREE.MathUtils.lerp(systemMa.material.opacity,0.8,alphaStep);systemFu.material.opacity=THREE.MathUtils.lerp(systemFu.material.opacity,0.8,alphaStep);horseOpacity.value=THREE.MathUtils.lerp(horseOpacity.value,0,alphaStep);}else{horseOpacity.value=THREE.MathUtils.lerp(horseOpacity.value,1.0,alphaStep);if(currentState==='ONE_HORSE'){let allAbsorbed=true;for(let i=0;i<RAIN_COUNT;i++){if(!rainPositionsMa[i].absorbed||!rainPositionsFu[i].absorbed){allAbsorbed=false;break;}}
if(allAbsorbed){systemMa.material.opacity=THREE.MathUtils.lerp(systemMa.material.opacity,0,alphaStep*2);systemFu.material.opacity=THREE.MathUtils.lerp(systemFu.material.opacity,0,alphaStep*2);}else{systemMa.material.opacity=THREE.MathUtils.lerp(systemMa.material.opacity,0.8,alphaStep);systemFu.material.opacity=THREE.MathUtils.lerp(systemFu.material.opacity,0.8,alphaStep);}}else{systemMa.material.opacity=THREE.MathUtils.lerp(systemMa.material.opacity,0,alphaStep);systemFu.material.opacity=THREE.MathUtils.lerp(systemFu.material.opacity,0,alphaStep);}
if(currentState==='MANY_HORSES'){systemHorse.material.uniforms.uBaseSize.value=THREE.MathUtils.lerp(systemHorse.material.uniforms.uBaseSize.value,0.38*window.devicePixelRatio,0.05);scene.fog.density=THREE.MathUtils.lerp(scene.fog.density,0.003,0.03);}else{systemHorse.material.uniforms.uBaseSize.value=THREE.MathUtils.lerp(systemHorse.material.uniforms.uBaseSize.value,0.12*window.devicePixelRatio,0.05);scene.fog.density=THREE.MathUtils.lerp(scene.fog.density,0.015,0.03);}}
let targetCamY,targetCamZ,targetLookY,targetCamX;if(currentState==='MANY_HORSES'){const handYInfluence=THREE.MathUtils.clamp((smoothHandY-0.3)*6,0,3);targetCamY=5.0+handYInfluence;targetCamZ=22.0;targetLookY=-1.0-handYInfluence*0.2;targetCamX=0;}else if(currentState==='ONE_HORSE'){targetCamY=2.5;targetCamZ=14;targetLookY=0;targetCamX=0;}else{targetCamY=2.5;targetCamZ=14;targetLookY=2.0;targetCamX=0;}
const camLerp=0.04;camera.position.x+=(targetCamX-camera.position.x)*camLerp;camera.position.y+=(targetCamY-camera.position.y)*camLerp;camera.position.z+=(targetCamZ-camera.position.z)*camLerp;if(!camera._lookY)camera._lookY=2.0;camera._lookY+=(targetLookY-camera._lookY)*camLerp;let shakeX=0,shakeY=0;let lookZ=-5;if(currentState==='MANY_HORSES'){const shakeAmp=0.1;shakeX=Math.sin(globalTime*8)*shakeAmp+Math.sin(globalTime*13)*shakeAmp*0.4;shakeY=Math.cos(globalTime*10)*shakeAmp*0.5;lookZ=-10;}
camera.lookAt(shakeX,camera._lookY+shakeY,lookZ);const targetFov=(currentState==='MANY_HORSES')?85:50;camera.fov+=(targetFov-camera.fov)*0.03;camera.updateProjectionMatrix();if(systemMa.material.opacity>0.01){const pMa=systemMa.geometry.attributes.position.array;const pFu=systemFu.geometry.attributes.position.array;const attractX=horseGroupX;const attractY=(currentState==='ONE_HORSE')?-1.0:0;const attractZ=0;const isAttracting=(currentState==='MANY_HORSES');const isOneHorse=(currentState==='ONE_HORSE');for(let i=0;i<RAIN_COUNT;i++){if(isOneHorse){if(!rainPositionsMa[i].absorbed){const ax=attractX-rainPositionsMa[i].x;const ay=-3.5-rainPositionsMa[i].y;const az=attractZ-rainPositionsMa[i].z;const distMa=Math.sqrt(ax*ax+ay*ay+az*az);const pull=Math.min(0.08+3.0/(distMa+0.5),0.5);rainPositionsMa[i].x+=ax*pull;rainPositionsMa[i].y+=ay*pull;rainPositionsMa[i].z+=az*pull;if(distMa<2.0){rainPositionsMa[i].absorbed=true;rainPositionsMa[i].x=9999;rainPositionsMa[i].y=9999;rainPositionsMa[i].z=9999;}}
if(!rainPositionsFu[i].absorbed){const bx=attractX-rainPositionsFu[i].x;const by=-3.5-rainPositionsFu[i].y;const bz=attractZ-rainPositionsFu[i].z;const distFu=Math.sqrt(bx*bx+by*by+bz*bz);const pull=Math.min(0.08+3.0/(distFu+0.5),0.5);rainPositionsFu[i].x+=bx*pull;rainPositionsFu[i].y+=by*pull;rainPositionsFu[i].z+=bz*pull;if(distFu<2.0){rainPositionsFu[i].absorbed=true;rainPositionsFu[i].x=9999;rainPositionsFu[i].y=9999;rainPositionsFu[i].z=9999;}}}else if(isAttracting){const ax=attractX-rainPositionsMa[i].x;const ay=attractY-rainPositionsMa[i].y;const az=attractZ-rainPositionsMa[i].z;const distMa=Math.sqrt(ax*ax+ay*ay+az*az)+0.1;const pullMa=Math.min(0.06+2.0/(distMa*distMa),0.3);rainPositionsMa[i].x+=ax*pullMa;rainPositionsMa[i].y+=ay*pullMa;rainPositionsMa[i].z+=az*pullMa;const bx=attractX-rainPositionsFu[i].x;const by=attractY-rainPositionsFu[i].y;const bz=attractZ-rainPositionsFu[i].z;const distFu=Math.sqrt(bx*bx+by*by+bz*bz)+0.1;const pullFu=Math.min(0.06+2.0/(distFu*distFu),0.3);rainPositionsFu[i].x+=bx*pullFu;rainPositionsFu[i].y+=by*pullFu;rainPositionsFu[i].z+=bz*pullFu;}else{rainPositionsMa[i].y-=rainPositionsMa[i].speed;if(rainPositionsMa[i].y<-12)rainPositionsMa[i].y=22;rainPositionsFu[i].y-=rainPositionsFu[i].speed;if(rainPositionsFu[i].y<-12)rainPositionsFu[i].y=22;}
pMa[i*3]=rainPositionsMa[i].x;pMa[i*3+1]=rainPositionsMa[i].y;pMa[i*3+2]=rainPositionsMa[i].z;pFu[i*3]=rainPositionsFu[i].x;pFu[i*3+1]=rainPositionsFu[i].y;pFu[i*3+2]=rainPositionsFu[i].z;}
systemMa.geometry.attributes.position.needsUpdate=true;systemFu.geometry.attributes.position.needsUpdate=true;}
const dustTargetOpacity=(currentState==='MANY_HORSES')?0.35:0;systemDust.material.opacity+=(dustTargetOpacity-systemDust.material.opacity)*0.06;if(systemDust.material.opacity>0.01){const pD=systemDust.geometry.attributes.position.array;for(let i=0;i<DUST_COUNT;i++){const d=dustPositions[i];d.x+=d.vx;d.y+=d.vy;d.z+=d.vz;d.vy-=0.002;d.life-=0.006;if(d.life<=0||d.y<-4){d.x=(Math.random()-0.5)*35+horseGroupX;d.y=Math.random()*0.8-2;d.z=(Math.random()-0.5)*30-5;d.vx=(Math.random()-0.5)*0.4;d.vy=Math.random()*0.25+0.05;d.vz=(Math.random()-0.5)*0.4+0.2;d.life=0.4+Math.random()*0.6;}
pD[i*3]=d.x;pD[i*3+1]=d.y;pD[i*3+2]=d.z;}
systemDust.geometry.attributes.position.needsUpdate=true;}
const starTargetOpacity=(currentState==='ONE_HORSE')?1.0:0;systemStars.material.uniforms.uOpacity.value+=(starTargetOpacity-systemStars.material.uniforms.uOpacity.value)*0.04;if(systemStars.material.uniforms.uOpacity.value>0.005){const sS=systemStars.geometry.attributes.aSize.array;for(let i=0;i<STAR_COUNT;i++){const s=starData[i];const twinkle=0.15+0.85*Math.pow((Math.sin(globalTime*s.twinkleSpeed+s.twinklePhase)+1)*0.5,3);sS[i]=s.baseSize*twinkle;}
systemStars.geometry.attributes.aSize.needsUpdate=true;}
if(horseOpacity.value>0.01){const pos=systemHorse.geometry.attributes.position.array;const bodyDefault=getBodyMotion(globalTime);const isManyHorses=(currentState==='MANY_HORSES');const tX=isManyHorses?(smoothHandX-0.5)*22+4.0:0;horseGroupX+=(tX-horseGroupX)*0.05;if(isManyHorses){const targetRot=DEFAULT_ROTATION+smoothHandAngle*0.6;horseRotationY+=(targetRot-horseRotationY)*0.05;}
const cosR=Math.cos(horseRotationY),sinR=Math.sin(horseRotationY);const tiltAngle=-0.15;const cosT=Math.cos(tiltAngle),sinT=Math.sin(tiltAngle);const verticalOffset=(currentState==='ONE_HORSE')?-3.5:-2.0;const lSpeed=(currentState==='ONE_HORSE')?0.2:0.3;for(let i=0;i<HORSE_COUNT;i++){const idx=i*3;const target=targetPositions[i%targetPositions.length];const bone=target.bone;const tParam=target.t||0;let horseId=isManyHorses?(i%TOTAL_HORSES):0;const body=(isManyHorses&&horseId>0)?getManyHorseBodyMotion(globalTime,horseId):bodyDefault;let tx=target.x,ty=target.y,tz=target.z;ty+=body.bounce;if(forwardIsZ){ty+=body.pitch*tz;tx+=body.roll*ty;}
else{ty+=body.pitch*tx;tz+=body.roll*ty;}
if(currentState==='ONE_HORSE'&&bone==='body'){ty+=Math.sin(globalTime*1.2)*0.015;}
if(bone.startsWith('leg')){const nF=target.nForward||0.5;const nS=target.nSide||0.5;if(isManyHorses){const gait=getManyHorseGallop(globalTime,nF,nS,horseId);const anchoredT=Math.max(0,(tParam-0.15)/0.85);const influence=Math.pow(anchoredT,1.2)*1.8;if(forwardIsZ){tz+=gait.stride*influence;}
else{tx+=gait.stride*influence;}
ty+=gait.liftY*influence;const kneeFactor=Math.sin(tParam*Math.PI);ty+=gait.kneeBendY*kneeFactor;if(forwardIsZ){tz+=gait.kneeBendForward*kneeFactor;}
else{tx+=gait.kneeBendForward*kneeFactor;}}else{const phaseOffset=horseId*1.3;const gait=getGallop(globalTime+phaseOffset,nF,nS);const anchoredT=Math.max(0,(tParam-0.15)/0.85);const influence=Math.pow(anchoredT,1.2);if(forwardIsZ){tz+=gait.stride*influence;}
else{tx+=gait.stride*influence;}
ty+=gait.liftY*influence;const kneeFactor=Math.sin(tParam*Math.PI);ty+=gait.kneeBendY*kneeFactor;if(forwardIsZ){tz+=gait.kneeBendForward*kneeFactor;}
else{tx+=gait.kneeBendForward*kneeFactor;}}}
if(bone==='neck'){const neckSpeed=isManyHorses?RUN_SPEED_SCALE*2.6:RUN_SPEED_SCALE*2;const neckAmp=isManyHorses?0.15:0.08;const phOff=isManyHorses?horseId*2.7:0;const s=Math.sin((globalTime+phOff)*neckSpeed)*neckAmp;if(forwardIsZ){tz+=s*tParam;}else{tx+=s*tParam;}
ty+=s*0.5*tParam;}
if(bone==='head'){const headSpeed=isManyHorses?RUN_SPEED_SCALE*2.6:RUN_SPEED_SCALE*2;const headAmp=isManyHorses?0.2:0.1;const phOff=isManyHorses?horseId*2.7:0;const nod=Math.sin((globalTime+phOff)*headSpeed)*headAmp;ty+=nod;if(forwardIsZ){tz+=nod*0.3;}else{tx+=nod*0.3;}}
if(bone==='mane'){const maneScale=isManyHorses?1.8:1.0;const phOff=isManyHorses?horseId*1.9:0;const w1=Math.sin((globalTime+phOff)*6+tParam*8)*0.2*maneScale;const w2=Math.sin((globalTime+phOff)*9+tParam*5)*0.1*maneScale;if(forwardIsZ){tz-=Math.abs(w1)*0.3;tx+=w2;}
else{tx-=Math.abs(w1)*0.3;tz+=w2;}
ty+=w1*0.2;}
if(bone==='tail'){const tailScale=isManyHorses?1.5:1.0;const phOff=isManyHorses?horseId*1.9:0;const w=Math.sin((globalTime+phOff)*5+tParam*6)*tParam*0.5*tailScale;const w2=Math.cos((globalTime+phOff)*7+tParam*4)*tParam*0.3*tailScale;tz+=w;ty+=w2*0.2;}
let localOffX=0,localOffZ=0,sc=1.0;let depthOffset=0;if(horseId>0&&horseFormation){const f=horseFormation[horseId];localOffX=f.offX;localOffZ=f.offZ;sc=f.sc;depthOffset=((globalTime*6*f.rushSpeed+f.rushPhase)%50)-25;localOffZ+=Math.sin(globalTime*1.5+horseId*2.1)*1.2;}
if(isManyHorses){const origY=ty,origFwd=forwardIsZ?tz:tx;const newY=origY*cosT-origFwd*sinT;const newFwd=origY*sinT+origFwd*cosT;ty=newY;if(forwardIsZ){tz=newFwd;}else{tx=newFwd;}}
const rotX=tx*cosR+tz*sinR;const rotZ=-tx*sinR+tz*cosR;const fX=(rotX*sc)+(localOffX*cosR+localOffZ*sinR)+horseGroupX;const fY=ty*sc+verticalOffset;const fZ=(rotZ*sc)+(-localOffX*sinR+localOffZ*cosR)+depthOffset;pos[idx]+=(fX-pos[idx])*lSpeed;pos[idx+1]+=(fY-pos[idx+1])*lSpeed;pos[idx+2]+=(fZ-pos[idx+2])*lSpeed;}
systemHorse.geometry.attributes.position.needsUpdate=true;}}
async function startAR(){const hands=new Hands({locateFile:(file)=>`libs/mediapipe/${file}`});hands.setOptions({maxNumHands:1,modelComplexity:0,minDetectionConfidence:0.6,minTrackingConfidence:0.6});hands.onResults(onResults);const stream=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480,facingMode:"user"}});videoElement.srcObject=stream;videoElement.onloadeddata=()=>{const run=async()=>{await hands.send({image:videoElement});requestAnimationFrame(run);};run();};}
function onResults(results){if(results.multiHandLandmarks&&results.multiHandLandmarks.length>0){isHandDetected=true;const lm=results.multiHandLandmarks[0];handCenterX=1.0-(lm[5].x+lm[17].x)/2;handCenterY=(lm[5].y+lm[17].y)/2;const dx=lm[17].x-lm[5].x;const dy=lm[17].y-lm[5].y;handAngle=Math.atan2(dy,dx);let folded=0;[8,12,16,20].forEach(idx=>{if(Math.hypot(lm[idx].x-lm[0].x,lm[idx].y-lm[0].y)<0.28)folded++;});const newState=(folded>=4)?'ONE_HORSE':'MANY_HORSES';if(newState!==pendingState){pendingState=newState;stateTimer=0;}}else{isHandDetected=false;if(pendingState!=='RAIN'){pendingState='RAIN';stateTimer=0;}}}
function init(){scene=new THREE.Scene();scene.fog=new THREE.FogExp2(0x1a0500,0.015);clock=new THREE.Clock();camera=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,500);camera.position.set(0,2.5,14);camera.lookAt(0,2.0,0);renderer=new THREE.WebGLRenderer({canvas:document.getElementById('output_canvas'),alpha:true,antialias:true});renderer.setSize(window.innerWidth,window.innerHeight);renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));loadingText.textContent='正在加载3D马模型...';const loader=new GLTFLoader();loader.load('models/Horse.glb',(gltf)=>{const mesh=gltf.scene.children[0];if(mesh.isMesh){generateHorseFromModel(mesh,gltf);}else{mesh.traverse(child=>{if(child.isMesh&&!modelLoaded){generateHorseFromModel(child,gltf);}});}
initParticleSystems();startAR();animate();},(progress)=>{if(progress.total>0){const pct=Math.round(progress.loaded/progress.total*100);loadingText.textContent=`加载模型中... ${pct}%`;}},(error)=>{console.error('模型加载失败:',error);loadingText.textContent='模型加载失败，请检查网络';});}
function animate(){requestAnimationFrame(animate);updateLogic();renderer.render(scene,camera);}
window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);});init();</script></body></html>